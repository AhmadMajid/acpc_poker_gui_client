- if @match_view.no_limit?
  :javascript
    ActionDashboard.adjustWagerOnSubmission(
      parseInt("#{@match_view.minimum_wager_to.to_i}"),
      parseInt("#{@match_view.user_contributions_in_previous_rounds.to_i}"),
      parseInt("#{@match_view.all_in.to_i}")
    );
    ActionDashboard.fixEnterWagerSubmission();

    var sliderValues;
    sliderValues = [
      parseInt("#{@match_view.minimum_wager_to.to_i}"),
      parseInt("#{(@match_view.pot_fraction_wager_to(1 / 2.to_f)).to_i}"),
      parseInt("#{(@match_view.pot_fraction_wager_to(3 / 4.to_f)).to_i}"),
      parseInt("#{@match_view.pot_fraction_wager_to.to_i}"),
      parseInt("#{(@match_view.pot_fraction_wager_to(2)).to_i}"),
      parseInt("#{@match_view.all_in.to_i}")
    ];
    WagerAmountSlider.initialize(sliderValues);
:javascript
  ws.onmessage = function(e) {
    switch (e.data) {
    case "#{ApplicationDefs::PLAY_ACTION_REQUEST_CODE}":
      console.log("Recieved #{ApplicationDefs::PLAY_ACTION_REQUEST_CODE}");
      $('#hidden-update_state').submit();
      break;
    default:
      // @todo Handle this better
      console.log('Unidentified reply: ' + e.data);
      break;
    };
  };
  var match_id = "#{@match_view.match.id}";
  var request = "#{ApplicationDefs::PLAY_ACTION_REQUEST_CODE}";
  $('.fold').click(function() {
    sendAndLog(ws,
      JSON.stringify(
        {
          request: request,
          match_id: match_id,
          action: "#{AcpcPokerTypes::PokerAction::FOLD}"
        }
      )
    );
  });
  $('.pass').click(function() {
    sendAndLog(ws,
      JSON.stringify(
        {
          request: request,
          match_id: match_id,
          action: "#{AcpcPokerTypes::PokerAction::CALL}"
        }
      )
    );
  });
  $('.wager').click(function() {
    sendAndLog(ws,
      JSON.stringify(
        {
          request: request,
          match_id: match_id,
          action: "#{AcpcPokerTypes::PokerAction::RAISE}" + $('.wager_amount-num_field > input#modifier').val()
        }
      )
    );
  });
  $(".#{next_hand_id}").click(function() {
    $('#hidden-update_state').submit();
  });
  // Must be done after initializing the websocket message sending click handlers
  ActionDashboard.disableButtonsOnClick();

-# @todo Unify this condition with that in update
- unless (@match_view.slice.users_turn_to_act? && @match_view.match.slices.length == 1) || @match_view.slice.match_ended? || @match_view.slice.hand_ended?
  :javascript
    $('#hidden-update_state').submit();

.hidden
  / @todo Simplify this form
  = update_state_form @match_view.match.id, '', class: 'hidden', id: 'hidden-update_state'
= render partial: 'layouts/navbar', locals: {partial: 'navbar'}

.chip_balances
  %h4= "#{@match_view.match.match_name} <span class=\"right\">#{@match_view.slice.hand_number+1} / #{@match_view.match.number_of_hands}</span>".html_safe
  %table.table.table-striped
    %thead
      %tr
        %th Player
        %th Balance
    %tbody
      - @match_view.slice.players.each do |player|
        %tr
          %td= "#{player['name']}"
          - chip_balance = player['chip_balance'] + (if !@match_view.slice.hand_ended? && player['chip_contributions'].inject(:+) > 0 then player['chip_contributions'].inject(:+) else 0 end)
          %td= "#{chip_balance}"
.game_interface
  .poker_table
    - @match_view.opponents.sort_by { |opp| AcpcPokerTypes::Seat.new(opp['seat'], @match_view.players.length).seats_from(@match_view.user['seat'])  }.each_with_index do |opponent, i|
      .opponent{ :class => [acting_player_id(opponent['seat']), "opponent_#{i+1}_of_#{@match_view.opponents.length}"] }
        = render partial: 'held_player_information', locals: {player: opponent}
        = render partial: 'outer_player_information', locals: { player: opponent, round: @match_view.state.round, hand_ended: @match_view.slice.hand_ended?, seat_with_dealer_button: @match_view.slice.seat_with_dealer_button }

    .community_information
      .board_cards
        = render partial: 'cards', locals: {cards: @match_view.state.board_cards.flatten}
      .pot
        / @todo Assumes Doyle's game in multi-player
        - pot = if @match_view.slice.hand_ended? then 0 else @match_view.pot_at_start_of_round end
        - if pot > 0
          = render partial: 'player_actions/chip_stack', locals: { amount: pot }
      .summary_information
        %p= "Actions: #{@match_view.betting_sequence}"
        - if @match_view.slice.match_ended?
          %p The match has ended, thanks for playing!
    .user{ :class => acting_player_id(@match_view.user['seat']) }
      = render partial: 'outer_player_information', locals: { player: @match_view.user, round: @match_view.state.round, hand_ended: @match_view.slice.hand_ended?, seat_with_dealer_button: @match_view.slice.seat_with_dealer_button }
      = render partial: 'held_player_information', locals: { player: @match_view.user }

  - next_hand_button_should_be_visible = @match_view.slice.hand_ended? && !@match_view.slice.match_ended?

  .action_dashboard{ class: if @match_view.no_limit? then 'nolimit' else 'limit' end}
    - if @match_view.slice.match_ended?
      .meta_action
        - leave_match_class= 'leave-btn'
        = button_tag leave_match_label, data: { disable_with: leave_match_label }, class: leave_match_class
    - elsif next_hand_button_should_be_visible
      .meta_action
        - next_hand_label = "Next Hand"
        %button{ class: next_hand_id, data: { disable_with: next_hand_label } }= next_hand_label
    - else
      - fold_is_disabled_when = !(@match_view.slice.users_turn_to_act? && @match_view.slice.legal_actions.include?(AcpcPokerTypes::PokerAction::FOLD))
      - pass_action_button_label = if (@match_view.slice.legal_actions.include?(AcpcPokerTypes::PokerAction::CALL) && @match_view.user['amount_to_call'] > 0) then (if @match_view.no_limit? then "Call (#{@match_view.user['amount_to_call'].to_i})" else 'Call' end) else 'Check' end
      - make_wager_button_label = if @match_view.slice.legal_actions.include?('b') then 'Bet' else 'Raise' end
      - make_wager_button_label += ' to' if @match_view.no_limit?
      .action_modification_tools
        - if @match_view.no_limit?
          .wager_amount-slider
            .slider_labels
              .slider_label.min Min
              .slider_label.half_pot 50%
              .slider_label.three_quarters_pot 75%
              .slider_label.one_pot Pot
              .slider_label.two_pot 2xPot
              .slider_label.all_in All-in
            .slider
              .ui_slider
          .wager_amount-num_field= number_field_tag :modifier, @match_view.minimum_wager_to.to_i, min: @match_view.minimum_wager_to.to_i, max: @match_view.all_in.to_i, step: @match_view.match.min_wagers[@match_view.state.round].to_i
      .actions
        .poker_actn_btn
          - fold_label = 'Fold'
          - fold_attributes = { type: 'submit', data: { disable_with: fold_label }}
          - fold_attributes[:disabled] = 'disabled' if fold_is_disabled_when
          %button.fold{fold_attributes}= fold_label
        .poker_actn_btn
          - pass_attributes = { type: 'submit', data: { disable_with: pass_action_button_label }}
          - pass_attributes[:disabled] = 'disabled' if !@match_view.slice.users_turn_to_act?
          %button.pass{pass_attributes}= pass_action_button_label
        .poker_actn_btn
          - wager_disabled_when = !@match_view.slice.users_turn_to_act? || !(@match_view.slice.legal_actions.include?(AcpcPokerTypes::PokerAction::RAISE) || @match_view.slice.legal_actions.include?(AcpcPokerTypes::PokerAction::BET))
          - wager_attributes = { type: 'submit', data: { disable_with: make_wager_button_label }}
          - wager_attributes[:disabled] = 'disabled' if wager_disabled_when
          %button.wager{wager_attributes}= make_wager_button_label
:javascript
  ChipStackMutator.adjustAmountFontSizeOfAllStacks();
  // Must come before change in focus code and as late into loading the page as possible
  // to make sure the window fits exactly as expected.
  GameInterface.adjustScale();
- if @match_view.slice.match_ended?
  :javascript
    $("button.#{leave_match_class}").click(function() {
      $('#leave').click();
    })
    $("button.#{leave_match_class}").focus();
- elsif next_hand_button_should_be_visible
  :javascript
    $("##{next_hand_id}").focus();
- else
  :javascript
    if (Modernizr.inputtypes.number)
      $('.wager_amount-num_field > input#modifier').focus();
- Match.delete_match!(@match_view.match.id) if @match_view.slice.match_ended?