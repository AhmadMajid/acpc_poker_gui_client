- unless @hand_ended || @match_ended || @users_turn_to_act
  :coffeescript
    setTimeout(
      (-> $('#hidden-next_state').submit()),
      100
    )

- next_hand_id = 'next_state'
- leave_match_id = 'match_ended_leave'
- leave_match_confirmation_message = "Are you sure you want to leave this match?"
- leave_match_label = "Leave Match"
.navbar
  .navbar-inner
    %a.brand ACPC Poker GUI Client
    %ul.nav
      %li
        = link_to leave_match_label, leave_game_url, {remote: true, id: 'leave', data: { confirm:  leave_match_confirmation_message, disable_with: leave_match_label }}
      %li.dropdown
        %a.dropdown-toggle{:data => {:toggle => "dropdown"}, role: 'button', :href => "#"}= 'Hotkeys <b class="caret"></b>'.html_safe
        %table.table.table-striped.dropdown-menu.dropdown_table{role: 'menu'}
          %thead
            %tr
              %th Action
              %th Key
          %tbody
            %tr
              %td Fold
              %td A
            %tr
              %td Check / Call
              %td S
            %tr
              %td Bet / Raise
              %td D
            %tr
              %td Next Hand
              %td F
            %tr
              %td Leave Match
              %td Q
.chip_balances.hero-unit
  %h4= "#{@match.match_name} <span class=\"right\">#{@match_slice.hand_number+1} / #{@match.number_of_hands}</span>".html_safe
  %table.table.table-striped
    %thead
      %tr
        %th Player
        %th Balance
    %tbody
      - @players.each do |player|
        %tr
          %td= "#{player['name']}"
          %td= "#{player['chip_balance'] + (if !@hand_ended && player['chip_contributions'].sum > 0 then player['chip_contributions'].sum else 0 end)}"
- game_interface_id = if @is_no_limit
  - 'no_limit'
- else
  - 'limit'
.game_interface.span-24{ id: game_interface_id}
  .poker_table.span-24
    - opponent = @opponents[0]
    .information_about_an_opponent{ :id => acting_player_id(opponent['name']) }
      = render partial: 'held_player_information', locals: {player: opponent,
        player_whose_turn_is_next: @player_whose_turn_is_next,
        hand_ended: @hand_ended,
        player_with_the_dealer_button: @player_with_the_dealer_button,
        round: @round}
    .community_information
      %ul.board_cards
        = render partial: 'cards', locals: {cards: @board_cards.flatten}
      %ul.pot
        / @todo Assumes Doyle's game in multi-player
        - side_pot = if @hand_ended then 0 else @pot_values_at_start_of_round.sum end
        - if side_pot > 0
          .side_pot
            = render partial: 'player_actions/chip_stack', locals: { amount: side_pot }
      %ul.summary_information
        %li
          %p= "Actions: #{@action_summary}"
        - if @match_ended
          %li
            %p The match has ended, thanks for playing!
    .users_information{ :id => acting_player_id(@user['name']) }
      = render partial: 'held_player_information', locals: {player: @user,
        hand_ended: @hand_ended,
        player_with_the_dealer_button: @player_with_the_dealer_button,
        round: @round}

  - next_hand_button_should_be_visible = @hand_ended && !@match_ended
  - action_dashboard_id = if @is_no_limit
    - 'no_limit'
  - else
    - 'limit'

  - action_dashboard_grid_class = if @match_ended || next_hand_button_should_be_visible
    - 'span-8 prepend-8 append-8'
  - else
    - 'span-24'
  .action_dashboard{ id: action_dashboard_id, class:  action_dashboard_grid_class }
    .hidden
      = update_state_form @match_id, @match_slice_index, "Hidden update state", class: 'hidden', id: 'hidden-next_state', disabled: (@users_turn_to_act || @match_ended) && !@hand_ended
    - if @match_ended
      .meta_action
        = link_to leave_match_label, leave_game_url, {remote: true, data: { confirm:  leave_match_confirmation_message, disable_with: leave_match_label }}
    - elsif next_hand_button_should_be_visible
      .meta_action
        - next_hand_label = "Next Hand"
        = button_tag next_hand_label, id: next_hand_id, class: ['btn', 'btn-info', 'btn-block', 'poker_action_button'], disabled: !@hand_ended || @match_ended, data: { disable_with: next_hand_label }
    - else
      - fold_label = 'Fold'
      - fold_is_disabled_when = !(@users_turn_to_act && @legal_actions.include?('f'))
      - pass_action_button_label = if (@legal_actions.include?('c') && @amount_for_user_to_call > 0) then (if @is_no_limit then "Call (#{@amount_for_user_to_call})" else 'Call' end) else 'Check' end
      - make_wager_button_label = if @legal_actions.include?('b') then 'Bet' else 'Raise' end
      - make_wager_button_label += ' to' if @is_no_limit
      - wager_classes = if @is_no_limit then ['with_modifier'] else [] end
      .action_modification_tools
        - if @is_no_limit
          .wager_amount_slider.span-12.prepend-6
            .slider_label.span-2#min Min
            .slider_label.span-2#half_pot 50%
            .slider_label.span-2#three_quarters_pot 75%
            .slider_label.span-2#one_pot Pot
            .slider_label.span-2#two_times_pot 2xPot
            .slider_label.span-2.last#all_in All-in
            .ui_slider.span-12
        .hidden_action_forms.span-6.last
          = poker_action_form 'f', fold_label, fold_is_disabled_when, [], ['hidden-fold']
          = poker_action_form 'c', pass_action_button_label, !@users_turn_to_act, [], ['hidden-pass']
          = poker_action_form 'r', make_wager_button_label, !@users_turn_to_act, wager_classes, ['hidden-wager'] do |f|
            - if @is_no_limit
              - f.number_field :modifier, class: 'span-6 last'
      .actions.btn-group.span-24
        .span-8= button_tag fold_label, poker_action_submission_options(fold_label, fold_is_disabled_when, [], ['fold'])
        .span-8= button_tag pass_action_button_label, poker_action_submission_options(pass_action_button_label, !@users_turn_to_act, [], ['pass'])
        .span-8.last= button_tag make_wager_button_label, poker_action_submission_options(make_wager_button_label, !@users_turn_to_act, wager_classes, ['wager'])
:coffeescript
  ChipStackMutator.adjustAmountFontSizeOfAllStacks()

  # Inteface scale adjustment
  adjustScale = (elementToScale) ->
    widthRatio = $(window).width() / elementToScale.width()
    heightRatio = ($(window).height() - $('.navbar').height()) / elementToScale.height()
      
    smallestRatio = Math.min(heightRatio, widthRatio)
    
    elementToScale.css('-moz-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-webkit-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-ms-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-o-transform', 'scale(' + smallestRatio.toString() + ')')
    
    scaledHeight = elementToScale.height() * smallestRatio
    
    elementToScale.css({top: -(Math.ceil((elementToScale.height() - scaledHeight) / 2) - $('.navbar').height()), left: Math.floor(($(window).width() - elementToScale.width()) / 2)})
    
    # Inversely scale slider and adjust width manually
    slider = $('.ui_slider')
    inverseScaling = 1 / smallestRatio
    slider.css('-moz-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-webkit-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-ms-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-o-transform', 'scaleX(' + inverseScaling.toString() + ')')
    
    originalSliderWidth = 410 # Hardcoded slider width separate from that set in CSS, not sure how to get around this
    slider.width(originalSliderWidth * smallestRatio)
    slider.css({left: -(Math.floor((slider.width() - originalSliderWidth) / 2))})

  adjustScale($('.game_interface'))
  jQuery(window).resize(->
    adjustScale($('.game_interface'))
  )

  # Disable all buttons upon one being clicked
  $('.btn').click(->
    return if this.id is 'leave'

    $('.btn:not(.hidden)').attr("disabled", true)
    $(this).attr("disabled", false)
  )

  # Take actions
  takeAction = (idOfSubmissionElement)->
    submissionElement = $(idOfSubmissionElement)
    submissionElement.click() unless submissionElement.is(':disabled')

  registerHiddenAction = (triggerId)->
    $('#' + triggerId).click(->
      takeAction('#hidden-' + triggerId)
    )
  registerHiddenAction('fold')
  registerHiddenAction('pass')
  registerHiddenAction('wager')
  registerHiddenAction("#{next_hand_id}")

  # Adjust wager amount
  $('#hidden-wager.with_modifier').click(->
    wager_to_amount_over_round = parseInt($('input#user_poker_action_modifier').val())
    if !wager_to_amount_over_round or isNaN(wager_to_amount_over_round)
      wager_to_amount_over_round = parseInt("#{@minimum_wager}")
    wager_to_amount_over_hand = wager_to_amount_over_round + parseInt("#{@amount_user_has_contributed_over_previous_rounds}")

    $('input#user_poker_action_modifier').val(wager_to_amount_over_hand.toString())
  )

- if @is_no_limit
  :coffeescript
    sliderValues = [
      parseInt("#{@minimum_wager}"),
      parseInt("#{@half_pot_wager_amount}"),
      parseInt("#{@three_quarter_pot_wager_amount}"),
      parseInt("#{@pot_wager_amount}"),
      parseInt("#{@two_pot_wager_amount}"),
      parseInt("#{@all_in_amount}")
    ]
    WagerAmountSlider.initialize(sliderValues)

    $('#user_poker_action_modifier').focus() unless $.browser.mozilla
- if next_hand_button_should_be_visible
  :coffeescript
    $("##{next_hand_id}").focus()
- if @match_ended
  :coffeescript
    $("##{leave_match_id}").focus()