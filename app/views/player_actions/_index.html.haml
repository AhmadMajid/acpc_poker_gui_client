- unless @hand_ended || @match_ended || @users_turn_to_act
  :coffeescript
    setTimeout(
      (-> $('#hidden-next_state').submit()),
      100
    )

- leave_match_confirmation_message = "Are you sure you want to leave this match?"
- leave_match_label = "Leave Match"
.navbar
  .navbar-inner
    %a.brand ACPC Poker GUI Client
    %ul.nav
      %li
        = link_to leave_match_label, leave_game_url, {remote: true, id: 'leave', data: { confirm:  leave_match_confirmation_message, disable_with: leave_match_label }}
      %li.dropdown
        %a.dropdown-toggle{:data => {:toggle => "dropdown"}, role: 'button', :href => "#"}= 'Hotkeys <b class="caret"></b>'.html_safe
        %table.table.table-striped.dropdown-menu.dropdown_table{role: 'menu'}
          %thead
            %tr
              %th Action
              %th Key
          %tbody
            %tr
              %td Fold
              %td A
            %tr
              %td Check / Call
              %td S
            %tr
              %td Bet / Raise
              %td D
            %tr
              %td Next Hand
              %td F
            %tr
              %td Leave Match
              %td Q

.chip_balances.hero-unit
  %h4= "#{@match.match_name} <span class=\"right\">#{@match_slice.hand_number+1} / #{@match.number_of_hands}</span>".html_safe
  %table.table.table-striped
    %thead
      %tr
        %th Player
        %th Balance
    %tbody
      - @players.each do |player|
        %tr
          %td= "#{player['name']}"
          %td= "#{player['chip_balance'] + (if !@hand_ended && player['chip_contributions'].sum > 0 then player['chip_contributions'].sum else 0 end)}"

- game_interface_id = if @is_no_limit
  - 'no_limit'
- else
  - 'limit'
.game_interface{ id: game_interface_id}
  .poker_table
    - opponent = @opponents[0]
    .information_about_an_opponent{ :id => acting_player_id(opponent['name']) }
      = render partial: 'held_player_information', locals: {player: opponent,
        player_whose_turn_is_next: @player_whose_turn_is_next,
        hand_ended: @hand_ended,
        player_with_the_dealer_button: @player_with_the_dealer_button,
        round: @round}
    .community_information
      %ul.board_cards
        = render partial: 'cards', locals: {cards: @board_cards.flatten}
      %ul.pot
        / @todo Assumes Doyle's game in multi-player
        - side_pot = if @hand_ended then 0 else @pot_values_at_start_of_round.sum end
        - if side_pot > 0
          .side_pot
            = render partial: 'player_actions/chip_stack', locals: { amount: side_pot }
      %ul.summary_information
        %li
          %p= "Actions: #{@action_summary}"
        - if @match_ended
          %li
            %p The match has ended, thanks for playing!
    .users_information{ :id => acting_player_id(@user['name']) }
      = render partial: 'held_player_information', locals: {player: @user,
        hand_ended: @hand_ended,
        player_with_the_dealer_button: @player_with_the_dealer_button,
        round: @round}

  - next_hand_button_should_be_visible = @hand_ended && !@match_ended
  - action_dashboard_id = if @match_ended
    - 'leave_match'
  - elsif next_hand_button_should_be_visible
    - 'next_hand'
  - elsif @is_no_limit
    - 'no_limit'
  - else
    - 'limit'
  .action_dashboard.hero-unit{ id: action_dashboard_id }
    .hidden
      = update_state_form @match_id, @match_slice_index, "Hidden update state", class: 'hidden', id: 'hidden-next_state', disabled: (@users_turn_to_act || @match_ended) && !@hand_ended
    - if @match_ended
      .meta_action
        = link_to leave_match_label, leave_game_url, {remote: true, class: ['btn', 'btn-info', 'btn-large'], data: { confirm:  leave_match_confirmation_message, disable_with: leave_match_label }}
    - elsif next_hand_button_should_be_visible
      .meta_action
        - next_hand_label = "Next Hand"
        = button_tag next_hand_label, id: 'next_state', class: ['btn', 'btn-info', 'btn-large'], disabled: !@hand_ended || @match_ended, data: { disable_with: next_hand_label }
    - else
      - if @is_no_limit
        .wager_amount_slider
          .wrapper
            %ul.increment_labels
              %li.slider_label#min Min
              %li.slider_label#half_pot 50%
              %li.slider_label#three_quarters_pot 75%
              %li.slider_label#one_pot Pot
              %li.slider_label#two_times_pot 2xPot
              %li.slider_label#all_in All-in
            .ui_slider
      - fold_label = 'Fold'
      - fold_is_disabled_when = !(@users_turn_to_act && @legal_actions.include?('f'))
      - pass_action_button_label = if (@legal_actions.include?('c') && @amount_for_user_to_call > 0) then (if @is_no_limit then "Call (#{@amount_for_user_to_call})" else 'Call' end) else 'Check' end
      - make_wager_button_label = if @legal_actions.include?('b') then 'Bet' else 'Raise' end
      - make_wager_button_label += ' to' if @is_no_limit
      .hidden_action_forms
        -# @todo Remove simple form if possible and clean up
        = simple_form_for @user_poker_action, url: take_action_url, remote: true, validate: true do |f|
          = f.input :match_id, as: :hidden, input_html: { value: @match_id }
          = f.input :match_slice_index, as: :hidden, input_html: { value: @match_slice_index }
          = f.input :poker_action, as: :hidden, input_html: { value: 'f' }
          = poker_action_submission(fold_label, fold_is_disabled_when, [], ['hidden-fold'])
        = simple_form_for @user_poker_action, url: take_action_url, remote: true, validate: true do |f|
          = f.input :match_id, as: :hidden, input_html: { value: @match_id }
          = f.input :match_slice_index, as: :hidden, input_html: { value: @match_slice_index }
          = f.input :poker_action, as: :hidden, input_html: { value: 'c' }
          = poker_action_submission(pass_action_button_label, !@users_turn_to_act, [], ['hidden-pass'])
        = simple_form_for @user_poker_action, url: take_action_url, remote: true, validate: true do |f|
          = f.input :match_id, as: :hidden, input_html: { value: @match_id }
          = f.input :match_slice_index, as: :hidden, input_html: { value: @match_slice_index }
          = f.input :poker_action, as: :hidden, input_html: { value: 'r' }
          - if @is_no_limit
            = f.input :modifier, as: :integer, label: false, input_html: { value: @pot_wager_amount }
          = poker_action_submission(make_wager_button_label, !@users_turn_to_act, ['with_modifier'], ['hidden-wager'])
      .actions.btn-group
        = button_tag fold_label, poker_action_submission_options(fold_label, fold_is_disabled_when, [], ['fold'])
        = button_tag pass_action_button_label, poker_action_submission_options(pass_action_button_label, !@users_turn_to_act, [], ['pass'])
        = button_tag make_wager_button_label, poker_action_submission_options(make_wager_button_label, !@users_turn_to_act, ['with_modifier'], ['wager'])
:coffeescript
  ChipStackMutator.adjustAmountFontSizeOfAllStacks()

  # Inteface scale adjustment
  adjustScale = (elementToScale) ->
    widthRatio = $(window).width() / elementToScale.width()
    heightRatio = ($(window).height() - $('.navbar').height()) / elementToScale.height()
      
    smallestRatio = Math.min(heightRatio, widthRatio)
    
    elementToScale.css('-moz-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-webkit-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-ms-transform', 'scale(' + smallestRatio.toString() + ')')
    elementToScale.css('-o-transform', 'scale(' + smallestRatio.toString() + ')')
    
    scaledHeight = elementToScale.height() * smallestRatio
    deviationFromTop = Math.ceil((elementToScale.height() - scaledHeight) / 2) - $('.navbar').height()
    deviationFromLeft = Math.floor(($(window).width() - elementToScale.width()) / 2)
    
    elementToScale.css({top: -deviationFromTop, left: deviationFromLeft})

    # Inversely scale slider and adjust width manually
    slider = $('.ui_slider')
    inverseScaling = 1 / smallestRatio
    slider.css('-moz-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-webkit-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-ms-transform', 'scaleX(' + inverseScaling.toString() + ')')
    slider.css('-o-transform', 'scaleX(' + inverseScaling.toString() + ')')
    
    originalSliderWidth = 275 # Hardcoded slider width separate from that set in CSS, not sure how to get around this
    slider.width(originalSliderWidth * smallestRatio)
  adjustScale($('.game_interface'))
  jQuery(window).resize(->
    adjustScale($('.game_interface'))
  )

  # Disable all buttons upon one being clicked
  $('.btn').click(->
    return if this.id is 'leave'

    $('.btn:not(.hidden)').attr("disabled", true)
    $(this).attr("disabled", false)
  )

  # Adjust wager amount
  $('.btn.with_modifier').click(->
    wager_to_amount_over_round = $('input#user_poker_action_modifier').val()
    wager_to_amount_over_hand = parseInt(wager_to_amount_over_round) + parseInt("#{@amount_user_has_contributed_over_previous_rounds}")
      
    $('input#user_poker_action_modifier').val(wager_to_amount_over_hand)
  )

  # Take actions
  takeAction = (idOfSubmissionElement)->
    submissionElement = $(idOfSubmissionElement)
    submissionElement.click() unless submissionElement.is(':disabled')

  registerHiddenAction = (triggerId)->
    $('#' + triggerId).click(->
      takeAction('#hidden-' + triggerId)
    )
  registerHiddenAction('fold')
  registerHiddenAction('pass')
  registerHiddenAction('wager')

  registerHiddenAction('next_state')

- if @is_no_limit
  :coffeescript
    sliderValues = [
      parseInt("#{@minimum_wager}"),
      parseInt("#{@half_pot_wager_amount}"),
      parseInt("#{@three_quarter_pot_wager_amount}"),
      parseInt("#{@pot_wager_amount}"),
      parseInt("#{@two_pot_wager_amount}"),
      parseInt("#{@all_in_amount}")
    ]
    WagerAmountSlider.initialize(sliderValues)

    # Adjust wager amount slider
    nonAllInLabels = $('.slider_label:not(#all_in)')
    originalSliderWidth = 275 # Hardcoded slider width separate from that set in CSS, not sure how to get around this
    widthForEachLabel = (originalSliderWidth - $('.slider_label#all_in').outerWidth(true)) / nonAllInLabels.length
    $(label).width(widthForEachLabel) for label in nonAllInLabels