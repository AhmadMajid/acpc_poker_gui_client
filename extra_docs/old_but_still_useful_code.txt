


From DealerCommunication:  ####################################################
(This is Resque related stuff that will be moved into NewGameController)
   
   #@queue = :dealer_communication
   
   #def self.perform(port)
   #   begin
   #      DealerCommunication.new port
   #   rescue
   #      raise
   #   end
   #end

###############################################################################


From GameState tests: #########################################################
(Likely most of this will be moved into Javascript validations)
   # Handles improper user action submission
#   it "properly handles a negative bet size" do
#      #amount_string = '-11'
##      test_bet_action amount_string, amount_that_state_should_change_in_error
#      pending
#   end
#   it "properly handles a negative raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a decimal bet size" do
#      #amount = '11.1'
# #     test_bet_action amount, amount_that_state_should_change_in_error
#      pending
#   end
#   it "properly handles a decimal raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a zero bet size" do
#      pending
#      #amount = '11.1'
#      
#   end
#   it "properly handles a zero raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a non-number bet size" do
#      pending
#      #amount = '11.1'
#      
#   end
#   it "properly handles a non-number raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
   
   # Handles proper user action submission
   #it "submits bet action correctly" do
   #   amount = '11'
   #   test_bet_action amount
   #end
   
###############################################################################



From ModelTestHelper:  ########################################################
   def setup_error_test
      #expected_user_stack = @patient.current_user_stack
      #expected_pot_size = @patient.current_pot_size
      #expected_wager = @patient.current_wager
      #[expected_user_stack, expected_pot_size, expected_wager]
   end
   
   #def test_bet_action(amount)
      #expected_string = setup_action_test ACTION_TYPES[:raise], amount
      #
      #@patient.bet_by_amount(amount).should be == expected_string
   #end
   
   #def test_erroneous_bet_action(action_argument)
      #(expected_user_stack, expected_pot_size, expected_wager) = setup_error_test
      #
      #result = catch(:erroneous_bet_size) do @patient.bet_by_amount action_argument end
      #result.should be == IMPROPER_AMOUNT_MESSAGE
      #test_action_expectations expected_user_stack, expected_pot_size, expected_wager
   #end
   
   def amount_that_state_should_change_in_error
      '0'
   end

###############################################################################



From GameState:  ##############################################################
#Depricated ################################################################
   
   # TODO move to game_action_manager
   #def amount_valid?(amount)
   #   amount.kind_of?(Numeric) && amount > 0 && !amount.to_s.match(/\./)# TODO && amount is greater than or equal to min raise size and last raise size in this round
   #end
   #def is_heads_up?
      #2 == @game_definition.number_of_players
   #end
   #
   #def current_user_stack
   #   # TODO @chip_manager.current_user_stack
   #end
   #
   #def current_opponent_stacks
   #   # TODO @chip_manager.current_opponent_stacks
   #end
   #
   #def set_state_blinds_submitted
   #   # TODO get the chip manager to pay blinds
   #end
   #
   #def blind_positions_in_stack_list
   #   change_in_position_since_start_of_game = @user_stack_index - @match_state.position_relative_to_dealer
   #   
   #   log "blind_positions_in_stack_list: change_in_position_since_start_of_game: #{change_in_position_since_start_of_game}"
   #   
   #   big_blind_index = 0
   #   small_blind_index = 0
   #   if is_heads_up?
   #      big_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_big_blind] - change_in_position_since_start_of_game
   #      small_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_small_blind] - change_in_position_since_start_of_game;
   #   else
   #      big_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_big_blind] - change_in_position_since_start_of_game
   #      small_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_small_blind] - change_in_position_since_start_of_game;
   #   end
   #      
   #   log "blind_positions_in_stack_list: else: big_blind_index: #{big_blind_index}, small_blind_index: #{small_blind_index}"
   #   
   #   [big_blind_index, small_blind_index]
   #end
   #
   #def small_blind_position_in_stack_list
   #   
   #end
   #
   #def big_blind
   #   @game_definition.big_blind
   #end
   #
   #def small_blind
   #   @game_definition.small_blind
   #end
   #
   #def user_submits_big_blind?
   #   if is_heads_up?
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_big_blind] == current_position_relative_to_dealer
   #   else
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_big_blind] == current_position_relative_to_dealer
   #   end
   #end
   #
   #def user_submits_small_blind?
   #   if is_heads_up?
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_small_blind] == current_position_relative_to_dealer
   #   else
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_small_blind] == @current_position_relative_to_dealer
   #   end
   #end
   #
   #def current_position_relative_to_dealer
   #   @match_state.position_relative_to_dealer
   #end
   #
   ## Action interface methods #################################################
   ## TODO Link the documentation of these methods with their game_core counterparts and link them down to game_action_manager
   #
   #
   #def bet_by_amount(amount)
   #   #amount_value = amount.to_i
   #   #if amount_valid? amount_value
   #   #   #TODO adjust chip amounts
   #   #   raise_to_amount = amount_value + amount_already_in_pot_from_user
   #      take_action raise_to_amount.to_s + ACTION_TYPES[:raise]
   #   #else
   #   #   # TODO Throw error
   #   #end
   #end
   #
   #def call_current_wager
   #   # TODO adjust chip amounts
   #   take_action ACTION_TYPES[:call]
   #end
   #
   #def raise_by_amount(amount)
   #   #TODO calculate the amount needed to call and subtract it from the user's stack
   #   #subtract_amount_from_stack call_amount + amount
   #   #submit_action amount.to_s + ACTION_TYPES[:raise]
   #end
   #
   
###############################################################################