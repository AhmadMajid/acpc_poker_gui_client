From GameCore tests: ##########################################################
require 'spec_helper'
#require 'application_defs'

describe GameCore do

   #include ApplicationDefs
   
   #before(:each) do
   #   @dealer_communication = mock('AcpcDealerCommunicator')
   #   @raw_match_state =  MATCH_STATE_LABEL + ":1:1::" + arbitrary_hole_card_hand
   #   @dealer_communication.stubs(:gets).returns(@raw_match_state)
   #end
   
   #it "parses all available game definitions properly" do
   #   GAME_DEFINITION_FILE_NAMES.values.each do |game_definition_file_name|
   #      patient = catch(:game_error) do
   #         GameDefinition.new game_definition_file_name, @dealer_communication
   #      end
   #      describe "Parse the valid game definition file, \"#{game_definition_file_name}\"" do
   #         it "does not throw an error when #{game_definition_file_name} is parsed" do
   #            patient.should be_a_kind_of GameDefinition
   #         end
   #         it "parses #{game_definition_file_name} properly" do
   #            matched = parsed_game_definitions_match_original_definitions?(patient, game_definition_file_name)
   #            matched.should == true
   #         end
   #      end
   #   end
   #end
   #it "submits actions correctly" do
   #   for_each_game_definition_file do |patient|
   #      ACTION_TYPES.values.each do |action|
   #         expected_string = @raw_match_state + ':' + action + TERMINATION_STRING
   #         @dealer_communication.stubs(:puts).once.with(expected_string)
   #         patient.submit_action action
   #      end
   #   end
   #end
   #it "records the last opponent action correctly" do
   #   first_part_of_match_state = MATCH_STATE_LABEL + ":0:0:"
   #   second_part_of_match_state = ":" + arbitrary_hole_card_hand
   #   initial_match_state = first_part_of_match_state + second_part_of_match_state
   #   @dealer_communication.stubs(:gets).returns(initial_match_state)
   #   for_each_game_definition_file do |patient|
   #      ACTION_TYPES.values.each do |action|
   #         opponent_match_state = first_part_of_match_state + action + second_part_of_match_state
   #         @dealer_communication.stubs(:gets).returns(opponent_match_state)
   #         patient.update_match_state
   #         patient.last_opponent_action.should be == action
   #      end
   #      # Check a no limit action as well
   #      no_limit_action = ACTION_TYPES[:raise] + "123"
   #      opponent_match_state = first_part_of_match_state + no_limit_action + second_part_of_match_state
   #      @dealer_communication.stubs(:gets).returns(opponent_match_state)
   #      patient.update_match_state
   #      patient.last_opponent_action.should be == no_limit_action
   #   end      
   #end
   #
   #it "records the last user action correctly" do
   #   first_part_of_match_state = MATCH_STATE_LABEL + ":0:0:"
   #   second_part_of_match_state = ":" + arbitrary_hole_card_hand + "|"
   #   initial_match_state = first_part_of_match_state + second_part_of_match_state
   #   @dealer_communication.stubs(:gets).returns(initial_match_state)
   #   GAME_DEFINITION_FILE_NAMES.values.each do |game_definition_file_name|
   #      patient = catch(:game_error) do
   #         Game.new game_definition_file_name, @dealer_communication
   #      end
   #      patient.should be_a_kind_of Game
   #      ACTION_TYPES.values.each do |action|
   #         user_match_state = first_part_of_match_state + second_part_of_match_state + ":#{action}#{TERMINATION_STRING}"
   #         @dealer_communication.expects(:puts).with(user_match_state)
   #         patient.submit_action action
   #         patient.last_user_action.should be == action
   #      end
   #      # Check a no limit action as well
   #      no_limit_action = ACTION_TYPES[:raise] + "123"
   #      user_match_state = first_part_of_match_state + second_part_of_match_state + ":#{no_limit_action}#{TERMINATION_STRING}"
   #      @dealer_communication.expects(:puts).with(user_match_state)
   #      patient.submit_action no_limit_action
   #      patient.last_user_action.should be == no_limit_action
   #   end
   #end
   #
   #it "properly adjusts the current wager based on player actions" do
   #   pending "TODO"
   #end

end

###############################################################################


From GameState tests: #########################################################
(Likely most of this will be moved into Javascript validations)
   # Handles improper user action submission
#   it "properly handles a negative bet size" do
#      #amount_string = '-11'
##      test_bet_action amount_string, amount_that_state_should_change_in_error
#      pending
#   end
#   it "properly handles a negative raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a decimal bet size" do
#      #amount = '11.1'
# #     test_bet_action amount, amount_that_state_should_change_in_error
#      pending
#   end
#   it "properly handles a decimal raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a zero bet size" do
#      pending
#      #amount = '11.1'
#      
#   end
#   it "properly handles a zero raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
#   it "properly handles a non-number bet size" do
#      pending
#      #amount = '11.1'
#      
#   end
#   it "properly handles a non-number raise size" do
#      pending
#      #amount = '11'
#      #action = amount + ACTION_TYPES[:raise]
#      #expected_string = raw_match_state_string action
#      #@patient.take_bet_action(amount).should be == expected_string
#      #TODO check that the user's stack is updated correctly
#   end
   
   # Handles proper user action submission
   #it "submits bet action correctly" do
   #   amount = '11'
   #   test_bet_action amount
   #end
   
###############################################################################



From ModelTestHelper:  ########################################################
   def setup_error_test
      #expected_user_stack = @patient.current_user_stack
      #expected_pot_size = @patient.current_pot_size
      #expected_wager = @patient.current_wager
      #[expected_user_stack, expected_pot_size, expected_wager]
   end
   
   #def test_bet_action(amount)
      #expected_string = setup_action_test ACTION_TYPES[:raise], amount
      #
      #@patient.bet_by_amount(amount).should be == expected_string
   #end
   
   #def test_erroneous_bet_action(action_argument)
      #(expected_user_stack, expected_pot_size, expected_wager) = setup_error_test
      #
      #result = catch(:erroneous_bet_size) do @patient.bet_by_amount action_argument end
      #result.should be == IMPROPER_AMOUNT_MESSAGE
      #test_action_expectations expected_user_stack, expected_pot_size, expected_wager
   #end
   
   def amount_that_state_should_change_in_error
      '0'
   end

###############################################################################



From GameState:  ##############################################################
#Depricated ################################################################
   
   # TODO move to game_action_manager
   #def amount_valid?(amount)
   #   amount.kind_of?(Numeric) && amount > 0 && !amount.to_s.match(/\./)# TODO && amount is greater than or equal to min raise size and last raise size in this round
   #end
   #def is_heads_up?
      #2 == @game_definition.number_of_players
   #end
   #
   #def current_user_stack
   #   # TODO @chip_manager.current_user_stack
   #end
   #
   #def current_opponent_stacks
   #   # TODO @chip_manager.current_opponent_stacks
   #end
   #
   #def set_state_blinds_submitted
   #   # TODO get the chip manager to pay blinds
   #end
   #
   #def blind_positions_in_stack_list
   #   change_in_position_since_start_of_game = @user_stack_index - @match_state.position_relative_to_dealer
   #   
   #   log "blind_positions_in_stack_list: change_in_position_since_start_of_game: #{change_in_position_since_start_of_game}"
   #   
   #   big_blind_index = 0
   #   small_blind_index = 0
   #   if is_heads_up?
   #      big_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_big_blind] - change_in_position_since_start_of_game
   #      small_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_small_blind] - change_in_position_since_start_of_game;
   #   else
   #      big_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_big_blind] - change_in_position_since_start_of_game
   #      small_blind_index = BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_small_blind] - change_in_position_since_start_of_game;
   #   end
   #      
   #   log "blind_positions_in_stack_list: else: big_blind_index: #{big_blind_index}, small_blind_index: #{small_blind_index}"
   #   
   #   [big_blind_index, small_blind_index]
   #end
   #
   #def small_blind_position_in_stack_list
   #   
   #end
   #
   #def big_blind
   #   @game_definition.big_blind
   #end
   #
   #def small_blind
   #   @game_definition.small_blind
   #end
   #
   #def user_submits_big_blind?
   #   if is_heads_up?
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_big_blind] == current_position_relative_to_dealer
   #   else
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_big_blind] == current_position_relative_to_dealer
   #   end
   #end
   #
   #def user_submits_small_blind?
   #   if is_heads_up?
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_REVERSE_BLINDS[:submits_small_blind] == current_position_relative_to_dealer
   #   else
   #      BLIND_POSITIONS_RELATIVE_TO_DEALER_NORMAL_BLINDS[:submits_small_blind] == @current_position_relative_to_dealer
   #   end
   #end
   #
   #def current_position_relative_to_dealer
   #   @match_state.position_relative_to_dealer
   #end
   #
   ## Action interface methods #################################################
   ## TODO Link the documentation of these methods with their game_core counterparts and link them down to game_action_manager
   #
   #
   #def bet_by_amount(amount)
   #   #amount_value = amount.to_i
   #   #if amount_valid? amount_value
   #   #   #TODO adjust chip amounts
   #   #   raise_to_amount = amount_value + amount_already_in_pot_from_user
   #      take_action raise_to_amount.to_s + ACTION_TYPES[:raise]
   #   #else
   #   #   # TODO Throw error
   #   #end
   #end
   #
   #def call_current_wager
   #   # TODO adjust chip amounts
   #   take_action ACTION_TYPES[:call]
   #end
   #
   #def raise_by_amount(amount)
   #   #TODO calculate the amount needed to call and subtract it from the user's stack
   #   #subtract_amount_from_stack call_amount + amount
   #   #submit_action amount.to_s + ACTION_TYPES[:raise]
   #end
   #
   
###############################################################################